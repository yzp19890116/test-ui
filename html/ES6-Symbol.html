<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JavaScript的第七种数据类型Symbol</title>
</head>
<body>
</body>
<script>
    console.log("==================概述和使用方法:凡是属性名属于Symbol类型，都是独一无二的，可以保证不会与其他属性名产生冲突==================")
    let s = Symbol();//Symbol值通过Symbol函数生成，注意前面是没有new的
    console.log(typeof s);

    let s1 = Symbol('foo');//Symbol函数可以接受一个字符串参数，表示对Symbol实例的描述，主要为了在控制台展示
    let s2 = Symbol('bar');
    console.log(s1);
    console.log(s2);

    const obj = {
        toString(){
            return 'abc'
        }
    }
    let s3 = Symbol(obj);
    console.log(s3);//Symbol(abc),如果参数是一个对象，则调用对象的toString方法，将其转为字符串，然后生成Symbol值

    let s11 = Symbol();
    let s12 = Symbol();
    console.log(s11 === s12);//false,凡是Symbol类型的都是独一无二的
    let s13 = Symbol('1')
    let s14 = Symbol('test')
    console.log(s13 === s14);//加参数的也一样
    console.log(s13 == s14);//双等号返回的也是false

    //"test " + s11;//Uncaught TypeError: Cannot convert a Symbol value to a string, Symbol值不能与其他类型的值进行计算
    // `test ${s11}`
    console.log(String(s13));//可以用两种方法转换成string类型
    console.log(s13.toString());

    console.log(Boolean(s13));//可以转换成boolean类型
    console.log(!s13);

    // Number(s13);//Uncaught TypeError: Cannot convert a Symbol value to a number,但是不能转成数值类型
    // s13 + 1

    console.log("==================Symbol.prototype.description：就是返回创建Symbol时的描述==================")
    console.log(s14.description);//test，区别于toSting方法返回的Symbol(test)


    console.log("==================作为属性名的 Symbol ==================")
    let mySymbol = Symbol();

    //第一种写法
    let a = {};
    a[mySymbol] = 'Hello';

    //第二种写法
    let b = {
        [mySymbol]: 'hello'//对象内部使用Symbol值定义属性时，Symbol值必须放在方括号之中
    }

    //第三种写法
    let c = {};
    Object.defineProperty(c, mySymbol, {value: 'hello'});

    console.log(a[mySymbol]);//三个结果都是一样的
    console.log(b[mySymbol]);
    console.log(c[mySymbol]);

    console.log("==================消除魔法数字==================")

    //普通的写法，这里"Triangle"就是魔法数字
    function getArea(shape, options){
        let area = 0;
        switch(shape){
            // case 'Triangle':
            case shapeType.triangle: //这个改成从变量中取值
                area = .5 * options.width * options.height;
                break;
        }
        return area;
    }

    const shapeType = {
        // triangle: 'triangle',
        triangle: Symbol()//仔细分析发现其实后面这个是什么值都可以，使用Symbol的好处就是不会冲突，之后变量中的值判断，就不会出错
    }

    console.log("==================属性名遍历==================")
    //Symbol作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。
    const blObj = {};
    let blA = Symbol('A');
    let blB = Symbol('B');

    blObj[blA] = 'hello';
    blObj[blB] = 'word';
    blObj["jth"] = '!';

    const objectSymbols = Object.getOwnPropertySymbols(blObj);
    console.log(objectSymbols);//0: Symbol(A);1: Symbol(B)
    for(let i in blObj){
        console.log(i);//["jth"]
    }
    console.log(Object.getOwnPropertyNames(blObj));//["jth"]

    //新的API提供了一个新的方法Reflect.ownKeys(),能返回正常的变量和Symbol变量
    console.log(Reflect.ownKeys(blObj));


    console.log("==================Symbol.for()，Symbol.keyFor()==================")

    let sf1 = Symbol('f1');
    let sf2 = Symbol.for('f1');
    let sf3 = Symbol.for('f1');
    console.log(sf1 === sf2);//false
    console.log(sf3 === sf2);//true

    //Symbol.keyFor()返回的是一个已登记的Symbol类型值的key
    console.log(Symbol.keyFor(sf1));//undefined
    console.log(Symbol.keyFor(sf2));//f1
    console.log(Symbol.keyFor(sf3));//f1

    //需要注意的是，Symbol.for为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。
    let iframe = document.createElement("iframe");
    iframe.src = String(window.location);
    document.body.appendChild(iframe);

    console.log(iframe.contentWindow.Symbol.for('foo') === Symbol.for('foo'));//true


    console.log("==================实例：模块的 Singleton 模式==================")

</script>

</html>