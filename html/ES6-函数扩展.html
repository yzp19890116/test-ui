<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>数值的扩展</title>
</head>
<body>

</body>
<script>
    console.log("==================函数参数的默认值==================")
    function log(x, y = 'Word'){
        console.log(x + y);
        //参数变量是默认声明的所有不能再用let或const再次声明
        // let x = 1;不管有没有默认值都不行
        // const y = 2;
    }
    log("Hello")
    log("Hello", "China")
    log("Hello", "")

    // 不报错
    function foo1(x, x, y) {
        // ...
    }

    // 报错，使用默认值，变量名不能重复，一般没人这么用
    // function foo2(x, x, y = 1) {
    //     // ...
    // }

    //参数默认值是惰性求值的，举个例子
    let lx = 99;
    function foo(x = lx + 1){
        console.log(x);
    }
    foo();
    lx = 200;
    foo()

    //与结构默认值一起使用
    function jgFun({x, y = 5}){
        console.log(x, y);
    }

    jgFun({});
    jgFun({x: 1});
    jgFun({x: 1});
    jgFun({x: 1, y: 2});
    // jgFun();由于x没有给默认值，报错

    //项目中常用的例子
    function fetch(url, {body= '', method= 'GET',headers = {}} = {}){
        console.log(method);
    }

    fetch("test.com")
    fetch("test.com", {method: 'fetch'})

    //两个默认值写法，经常看，经常练习, 默认参数一般使用在尾参数
    function m1({x = 0, y = 0} = {}){
        console.log(x, y)
    }
    function m2({x, y} = {x: 0, y: 0}){
        console.log(x, y)
    }

    m1({})
    m2({})

    //函数的length属性
    console.log((function(a){}).length);
    console.log((function(a = 1){}).length);
    console.log((function(a, b, c = 1){}).length);

    //不固定参数length就是0
    (function(...args) {}).length; // 0

    //设置了默认值的参数不是位数length也不计算后面的参数了
    (function (a = 0, b, c) {}).length; // 0
    (function (a, b = 1, c) {}).length; // 1

    console.log("==================作用域：设置了参数的默认值，函数进行声明初始化时，参数会行程一个单独的作用域==================")
    var zyyX = 1;
    function zyyF(zyyX, y = zyyX){
        console.log(y);
    }
    zyyF(2);//2

    let zyyX1 = 1;
    function zyyF1(y = zyyX1){
        let zyyX1 = 2;//参数y = zyyX1时行程一个单独的作用域，这个作用域中zyyX1还没声明就用全局的zyyX1
        console.log(y);
    }
    zyyF1();//1
    zyyF1(3);//3

    var zyyX2 = 1;
    function zyyF2(zyyX2, y = function(){ zyyX2 = 2}){
        // var zyyX2 = 3;
        zyyX2 = 3;
        y();
        console.log(zyyX2);//有var 值为1， 没有var值为2，因为没有var 方法中的zyyX2指向的就是第一个参数zyyX2，和y匿名函数中内部的zyyX2是一致的，而不是自定义作用域
    }
    zyyF2();

    //应用: 利用默认值可以指定某个参数是不能省略的
    function throwIfMissing(){
        throw new Error("Missing parameter");
    }
    function yyF(mustProvided = throwIfMissing()){
        return mustProvided;
    }
    //yyF();//此处如果必要参数没有传，就会抛出预设的异常


    console.log("==================rest参数==================")
    function add(...values){
        let sum = 0;
        values.forEach(function(item){
            sum += item;
        })
        console.log(sum);
    }
    add(1, 2, 3, 4);

    const sortNumbers = (...numbs) => numbs.sort();
    console.log(sortNumbers(2,5,6,3,4));

    function pushArr(array, ...items){
        items.forEach(function(item){
            array.push(item);
            console.log(item);
        })
        return array;
    }
    var arr = [];
    console.log(pushArr(arr, 1,3,5,6,2,3));

    console.log("==================严格模式：'use strict': es2016开始规定了使用了默认值、结构赋值、或者扩展运算，内部是不能显示定义严格模式的==================")
    //函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。
    //两个办法可以解决，1、定义全局的严格模式；2、吧函数抱在一个五参数的立即执行函数里
    const doSomeThing = (function(){
        'use strict';
        return function(value = 1){
            return value;
        }
    }())

    console.log("==================函数参数的默认值==================")
    console.log("==================函数参数的默认值==================")

</script>
</html>