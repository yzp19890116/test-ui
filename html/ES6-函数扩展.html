<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>数值的扩展</title>
</head>
<body>

</body>
<script>
    console.log("==================函数参数的默认值==================")
    function log(x, y = 'Word'){
        console.log(x + y);
        //参数变量是默认声明的所有不能再用let或const再次声明
        // let x = 1;不管有没有默认值都不行
        // const y = 2;
    }
    log("Hello")
    log("Hello", "China")
    log("Hello", "")

    // 不报错
    function foo1(x, x, y) {
        // ...
    }

    // 报错，使用默认值，变量名不能重复，一般没人这么用
    // function foo2(x, x, y = 1) {
    //     // ...
    // }

    //参数默认值是惰性求值的，举个例子
    let lx = 99;
    function foo(x = lx + 1){
        console.log(x);
    }
    foo();
    lx = 200;
    foo()

    //与结构默认值一起使用
    function jgFun({x, y = 5}){
        console.log(x, y);
    }

    jgFun({});
    jgFun({x: 1});
    jgFun({x: 1});
    jgFun({x: 1, y: 2});
    // jgFun();由于x没有给默认值，报错

    //项目中常用的例子
    function fetch(url, {body= '', method= 'GET',headers = {}} = {}){
        console.log(method);
    }

    fetch("test.com")
    fetch("test.com", {method: 'fetch'})

    //两个默认值写法，经常看，经常练习, 默认参数一般使用在尾参数
    function m1({x = 0, y = 0} = {}){
        console.log(x, y)
    }
    function m2({x, y} = {x: 0, y: 0}){
        console.log(x, y)
    }

    m1({})
    m2({})

    //函数的length属性
    console.log((function(a){}).length);
    console.log((function(a = 1){}).length);
    console.log((function(a, b, c = 1){}).length);

    //不固定参数length就是0
    (function(...args) {}).length; // 0

    //设置了默认值的参数不是位数length也不计算后面的参数了
    (function (a = 0, b, c) {}).length; // 0
    (function (a, b = 1, c) {}).length; // 1

    console.log("==================作用域：设置了参数的默认值，函数进行声明初始化时，参数会行程一个单独的作用域==================")
    var zyyX = 1;
    function zyyF(zyyX, y = zyyX){
        console.log(y);
    }
    zyyF(2);//2

    let zyyX1 = 1;
    function zyyF1(y = zyyX1){
        let zyyX1 = 2;//参数y = zyyX1时行程一个单独的作用域，这个作用域中zyyX1还没声明就用全局的zyyX1
        console.log(y);
    }
    zyyF1();//1
    zyyF1(3);//3

    var zyyX2 = 1;
    function zyyF2(zyyX2, y = function(){ zyyX2 = 2}){
        // var zyyX2 = 3;
        zyyX2 = 3;
        y();
        console.log(zyyX2);//有var 值为1， 没有var值为2，因为没有var 方法中的zyyX2指向的就是第一个参数zyyX2，和y匿名函数中内部的zyyX2是一致的，而不是自定义作用域
    }
    zyyF2();

    //应用: 利用默认值可以指定某个参数是不能省略的
    function throwIfMissing(){
        throw new Error("Missing parameter");
    }
    function yyF(mustProvided = throwIfMissing()){
        return mustProvided;
    }
    //yyF();//此处如果必要参数没有传，就会抛出预设的异常


    console.log("==================rest参数==================")
    function add(...values){
        let sum = 0;
        values.forEach(function(item){
            sum += item;
        })
        console.log(sum);
    }
    add(1, 2, 3, 4);

    const sortNumbers = (...numbs) => numbs.sort();
    console.log(sortNumbers(2,5,6,3,4));

    function pushArr(array, ...items){
        items.forEach(function(item){
            array.push(item);
            console.log(item);
        })
        return array;
    }
    var arr = [];
    console.log(pushArr(arr, 1,3,5,6,2,3));

    console.log("==================严格模式：'use strict': es2016开始规定了使用了默认值、结构赋值、或者扩展运算，内部是不能显示定义严格模式的==================")
    //函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。
    //两个办法可以解决，1、定义全局的严格模式；2、吧函数抱在一个五参数的立即执行函数里
    const doSomeThing = (function(){
        'use strict';
        return function(value = 1){
            return value;
        }
    }())

    console.log("==================name属性==================")
    function testName(){};
    console.log(testName.name);

    var testName1 = function (){}
    console.log(testName1.name);//es5返回“”，es6返回testName1

    const testName2 = function baz(){};
    console.log(testName2.name);//baz

    (new Function).name // "anonymous" function构造函数返回anoymous

    function foo() {};
    console.log(foo.bind({}).name); // "bound foo" bind 返回的函数，name属性前加上bound前缀

    console.log((function(){}).bind({}).name); // "bound "

    console.log("==================箭头函数，重中之重==================")
    //如果箭头函数代码块对于一条语句就要用大括号将他们括起来
    var logAndSum  = (num1, num2) => {
        console.log(num1 + num2);
        return num1 + num2;
    }

    //由于使用大括号解释为代码块，所以箭头函数如果要返回一个对象，必须在对象外面加上“（）”
    //let getTempItem = id => {id: id, name: "temp"};//Uncaught SyntaxError: Unexpected token : 意外的标记
    let getTempItem = id => ({id: id, name: "temp"});

    //如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，不用写大括号了
    let nFun = () => void doesNotReturn();

    //箭头函数和变量结构结合使用
    let full = ({firstName, lastName}) => {return firstName + "_" + lastName}
    console.log(full({firstName: "Hello", lastName: "Word"}));

    //箭头函数和rest参数的联用
    const numbers = (...nums) => nums;
    console.log(numbers(1,2,3,4,5))//将一串数字转成数组
    const headAndTail = (head, ...tails) => [head, tails];
    console.log(headAndTail('a','b','c','d','e'));

    //函数体内的this对象，就是定义是所在的对象，而不是使用时所在的对象
    function fooThis(){
        setTimeout(() => {
            console.log(this.id);
        },100);
    }
    var id = 23;
    fooThis.call({id: 22});//结果时22

    //下面有个烧脑的例子
    function Timer(){
        this.s1 = 0;
        this.s2 = 0;
        //箭头函数，这里的this指向的是timer中的s1
        setInterval(() => this.s1++ , 1000);
        //普通函数,这里的this指向的是全局的s2
        setInterval(function(){
            this.s2++;
        },1000)
    }

    var timer = new Timer();

    setTimeout(() => console.log(timer.s1),3100);//3
    setTimeout(() => console.log(timer.s2),3100);//0
    setTimeout(function(){console.log(timer.s1)},3100);//3和是否箭头调用没有关系
    setTimeout(function(){console.log(timer.s2)},3100);//0

    //又一个有些烧脑的方法, 下面的id都是1，因为箭头函数没有this,这里的this都是showIdFoo方法内部的
    function showIdFoo(){
        return () => {
            return () => {
                return () => {
                    console.log(this.id);
                };
            };
        };
    }
    var showIdF = showIdFoo.call({id: 1});
    var t1 = showIdF.call({id: 2})()();
    var t2 = showIdF().call({id: 3})();
    var t3 = showIdF()().call({id: 4});

</script>
</html>