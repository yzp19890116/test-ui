<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>对象的新增方法</title>
</head>
<body>
</body>
<script>
    console.log("==================Object.is()==================")
    //直接上用法，区别在于nan和0，-0的判断
    console.log(Object.is('foo', 'foo'));//true
    console.log(Object.is({}, {}));//false
    console.log(Object.is({a: 1}, {a: 1}));//false,还是不能判断两个指向不同地址的对象是否相等
    console.log(Object.is(NaN, NaN));//true
    console.log(Object.is(0, -0));//false

    console.log("==================Object.assign()：将source对象的所有可枚举属性复制到targer对象==================")
    const target = {a: 1, b: 1};
    const source1 = {b: 2, c: 1};
    const source2 = {c: 3};
    Object.assign(target, source1, source2);//后面的属性会覆盖前面的属性
    console.log(target);//{a: 1, b: 2, c: 3}
    console.log(source1);
    //如果assign方法只有一个参数，返回该参数
    console.log(Object.assign(target));

    //如果参数不是一个对象，先转为对象，不能转为对象的undefined,null会报错
    console.log(Object.assign(2));//number对象
    console.log(typeof Object.assign(2));//object
    // Object.assign(undefined);//报错
    // Object.assign(null);//报错
    //如果非对象参数出现在原对象位置，则会有不同结果，先转对象，如果转不了会跳过
    Object.assign(target, null, undefined);
    console.log(Object.assign(target, null, undefined) === target);//返回true

    //其他类型的值，即数值和布尔值，不在手参数，也不会报错，但是除了字符串会以数组刑事拷贝入对象，其他都不会产生效果,原因是只有字符串类型转化成相对应包装对象会产生可枚举的属性
    const v1 = 'abc';
    const v2 = 11;
    const v3 = true;
    console.log(Object.assign({}, v1, v2, v3));//{0: "a", 1: "b", 2: "c"}

    //assign方法拷贝是有限制的，只能拷贝原对象的自身属性，不可枚举属性不拷贝，Symbol是拷贝的
    console.log(Object.assign({a:1}, Object.defineProperty({}, 'invisible', {
        enumerable: false,
        value: 'hello'
    }), {[Symbol('b')]: 2}));//{a: 1, Symbol(b): 2}

    //以下是注意点
    //浅拷贝，与扩展运算符一样
    const obj1 = {a:{b: 1}};
    const obj2 = Object.assign(obj1);
    obj1.a.b = 2;
    console.log(obj2.a.b);//2
    //同名属性替换
    const obj3 = {a: {c: 3}};
    console.log(Object.assign(obj1, obj3));//{a:{c:3}},并不是{a:{b:2, c:3}},有提供了定制版本的assign比如Lodash的_.defaultDeep方法
    //数组的处理
    console.log(Object.assign([1,2,3], [4,5]));//[4,5,3]
    //函数处理，assing只能对值进行复制，如果要复制的值是一个取值函数，那么就复制函数返回值
    const source = {
        get foo(){
            return 1;
        }
    }
    console.log(Object.assign({},source));//{foo: 1}

    //常见用途
    //为对象添加属性
    class Point{
        constructor(x, y){
            Object.assign(this, {x, y})
        }
    };

    //为对象添加方法
    Object.assign(Point.prototype, {
        someMethod(arg1, arg2){
            //
        },
        otherMethod(){
            ///
        }
    })
    Point.prototype.someMethod = function(arg1, arg2){};//等同于

    //克隆对象
    function clone(origin){
        return Object.assign({}, origin);

    }

    console.log("==================Object.getOwnPropertyDescriptors()==================")


    console.log("==================扩展运算符:它好比rest参数的你运算==================")
</script>

</html>