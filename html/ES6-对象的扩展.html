<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>对象的扩展</title>
</head>
<body>
    <button id="press">按钮</button>
    <button id="press">按钮1</button>
    <button id="press">按钮2</button>
</body>
<script>
    console.log("==================属性的简洁表示法==================")
    //ES6允许直接写入变量和函数，作为对象的属性和方法
    const foo = 'bar';
    const bar = {foo};
    console.log(bar);
    const bar1 = {foo: foo};//和上面的写法一致
    console.log(bar1);

    //允许在对象中直接写变量，这时属性名为变量名，属性值为变量值
    function f(x, y){
        return {x, y}
    }
    //等同于
    function f1(x, y){
        return {x: x, y: y}
    }
    console.log(f(1, 2));
    console.log(f1(1, 2));

    //除了属性简写，方法也可以简写
    const o = {
        method(){
            return "Hello";
        }
    }
    //等同于
    const o1 = {
        method: function(){
            return "Hello";
        }
    }
    console.log(o.method());
    console.log(o1);

    //一个实用性的例子
    let birth = '2000/01/02';
    const Person = {
        name: 'zhangsan',
        birth,
        hello(){
            console.log('我的名字是', this.name, this.birth);
        }
    }
    Person.hello();

    //这种写法用于函数的返回，将会非常方便
    function getPoint(){
        const x = 1;
        const y = 2;

        return {x, y};
    }
    console.log(getPoint());

    //如果某个方法的值是一个Generator函数（yield），前面需要加上星号
    const obj = {
        *m(){
            yield 'hello word';
        }
    }

    console.log("==================属性名表达式==================")
    //JavaScript定义对象的属性有两种方法
    //方法一
    obj.foo = true;
    //方法二
    obj['a' + 'bv'] = 123;
    //ES6允许字面定义对象时，用方法二最为对象属性名，把表达式放在方括号内
    let propKey = 'foo';
    let obj1 = {
        [propKey]: 'true',
        ['a' + 'bc']: 123
    }
    console.log(obj1);//{foo: "true", abc: 123}
    //注意属性名表达式与简洁表示法不能同时使用，会报错
    const foo1 = 'bar2';
    const bar2 = 'abc';
    // const baz1 = {[foo1]};//Uncaught SyntaxError: Identifier 'bar1' has already been declared
    const baz2 = {[foo1]: bar2};
    console.log(baz2);
    //如果属性名表达式如果是一个对象，默认情况下会自动将对象转化成字符串[object object].这一点一定要小心
    const keyA = {a: 1};
    const keyB = {b: 2};
    const myObject = {
        [keyA]: 'valueA',
        [keyB]: 'valueB',
    }
    console.log(myObject);//{[object Object]: "valueB"}定义的对象也只有一个key，因为都转成了[object Object]

    console.log("==================方法的 name 属性==================")
    //函数的name属性返回函数名，对象的方法也是函数，因此也有name属性
    const person = {
        sayName(){
            console.log('Hello!');
        }
    }
    console.log(person.sayName.name);
    //如果对象的方法使用的取值函数（）和存值函数，则name属性不在该方法上面，而是该方法的属性的描述对象的get和set属性上面
    const obj2 = {
        get foo(){},
        set foo(x){}
    }
    console.log(obj.foo.name);//undefined
    //获取obj2对象的foo方法的描述对象
    const descriptor = Object.getOwnPropertyDescriptor(obj2, 'foo');

    console.log(descriptor);
    console.log(descriptor.get.name);
    console.log(descriptor.set.name);

    //两个特殊情况
    console.log((new Function()).name);//Function 构造函数创造的函数name返回anonymous
    var doSomeThing = function(){};
    console.log(doSomeThing.bind().name);//bound doSomeThing。bind方法创造的函数name返回bound + 原函数名

    var key1 = Symbol('test');
    var key2 = Symbol();
    let objSy = {
        [key1](){},
        [key2](){},
    }
    console.log(objSy[key1].name);//[test]
    console.log(objSy[key2].name);//返回空字符串

    console.log("==================属性的可枚举性和遍历==================")
    //对象的每个属性都有一个描述对象（Descriptor）,用来控制该属性的行为.Object.getOwnPropertyDescriptor()方法可以获取该属性
    let objmj = {foo: '123'};
    console.log(Object.getOwnPropertyDescriptor(objmj, 'foo'));
    //其中描述对象的enumerable属性成为“可枚举性”， 如果该属性为false，就表示某些操作会忽略当前属性
    //目前有四个操作会忽略enumerable属性为false的属性
    //for...in
    //Object.keys()
    //JSON.stringify()
    //Object.assign()//这个是ES6后加的，只拷贝对象自身的可枚举属性
    console.log(Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable);//toString属性的enumerable属性就是false
    console.log(Object.getOwnPropertyDescriptor([], 'length').enumerable);//length属性的enumerable属性也是false
    //另外ES6规定，Class的原型的方法都是不可枚举的
    console.log(Object.getOwnPropertyDescriptor(class{foo(){}}.prototype, 'foo').enumerable);

    console.log("==================扩展运算符:它好比rest参数的你运算==================")
    console.log("==================扩展运算符:它好比rest参数的你运算==================")
    console.log("==================扩展运算符:它好比rest参数的你运算==================")
    console.log("==================扩展运算符:它好比rest参数的你运算==================")
    console.log("==================扩展运算符:它好比rest参数的你运算==================")
</script>

</html>